# functions for visualising the outcome of consecutive Mantel tests

# for plotting error bars
if (suppressWarnings(require(Hmisc, quietly=TRUE))) {
  errbar <- Hmisc::errbar
} else {
  message("For prettier error bars, invoke: install.packages('Hmisc')")
  # ingenious solution thanks to http://stackoverflow.com/questions/13032777/scatter-plot-with-error-bars
  errbar <- function(x, y, yplus, yminus, errbar.col="black", ...) {
    plot(x, y, pch=20, ...)
    arrows(x, yplus, x, yminus, length=0.05, angle=90, code=3, col=errbar.col)
  }
}

red.if.na <- function(x, default="black") {
  mapply(function(x,d) if (is.na(x)) "red" else d, x, default)
}
blue.if.true <- function(x, default="black") {
  mapply(function(x,d) if (x) "blue" else d, x, default)
}
# combinable:
# blue.if.true(c(T, F, F), red.if.na(c(NA, NA, 3)))


# lookup table for plotting functions for different mantel test measures
mantel.plotfuns <- list()

mantel.plotfuns[["z"]] <- function(mantels, ylim=range(0, mantels$z)+c(0,1), col=blue.if.true(mantels$is.unique.max, red.if.na(mantels$p.smoothed)), ...) {
  plot(1:nrow(mantels), mantels$z, ylab="z score", ylim=ylim, col=col, ...)
  abline(h=0, lty=2, col="grey")
}

mantel.plotfuns[["r"]] <- function(mantels, ylim=range(0.1, mantels$veridical, mantels$mean+mantels$sd, mantels$mean-mantels$sd)+c(-0.1,0.1), xlab="", ...) {
  errbar(1:nrow(mantels), mantels$mean, mantels$mean+mantels$sd, mantels$mean-mantels$sd, xlab=xlab, ylab="r (meanÂ±sd)", ylim=ylim, errbar.col=red.if.na(mantels$p.smoothed), ...)
  # plot correlation coefficient reference points
  abline(h=-1:1, lty=c(3,2,3), col="grey")
  # blue points signify that no single larger r value has been sampled
  points(1:nrow(mantels), mantels$veridical, col=blue.if.true(mantels$is.unique.max))
  # label the veridical rs with their z scores
  text(1:nrow(mantels), mantels$veridical, labels=paste("z", round(mantels$z, digits=2), sep="="), pos=2+sign(mantels$z))
}

# grab the xaxt, xlab, xlim and ylim arguments to stop them from being passed on via ...
mantel.plotfuns[["msample"]] <- function(mantels, nbins=25, main="", xaxt=NULL, xlab=NULL, xlim=NULL, ylim=NULL, ...) {
  d <- list()
  if (nrow(mantels) > 1) {
    par(mfrow=c(1, nrow(mantels)), mar=c(5.1, 2.5, 2, 1))
  }
  maxdensity <- 0
  for (i in 1:nrow(mantels)) {
#    d[[i]] <- density(unlist(mantels$msample[i]))
    d[[i]] <- hist(unlist(mantels$msample[i]), breaks=nbins, plot=FALSE)
    maxdensity <- max(maxdensity, d[[i]]$density, dnorm(0, sd=mantels$sd[i]))
  }
  for (i in 1:nrow(mantels)) {
    xlim <- range(mantels$msample[i], mantels$veridical[i])
    plot(d[[i]], freq=FALSE, yaxs="i", xlim=xlim, ylim=c(0, maxdensity), xlab="r", ylab="Density", border="gray", main=paste("r=", round(mantels$veridical[i], digits=2), ", N=", mantels$sample.size[i], sep=""), ...)
    # add fit used for z score estimation
    curve({dnorm(x, mean=mantels$mean[i], sd=mantels$sd[i])}, col=red.if.na(mantels$p.smoothed[i]), lty=3, add=T)
    # mark veridical r
    col <- blue.if.true(mantels$is.unique.max[i])
    level <- dnorm(mantels$veridical[i], mean=mantels$mean[i], sd=mantels$sd[i])
    segments(mantels$veridical[i], 0, y1=level, col=col, lty=2)
    points(mantels$veridical[i], y=0.15+level, pch=25, bg=col, col=col)
    text(mantels$veridical[i], level, paste("z=", round(mantels$z[i], digits=2), sep=""), pos=3)
  }
}

#' Plot a Mantel test result.
#' 
#' Plots the result of one or more Mantel permutation tests. The exact
#' visualisation used can be controlled with the \code{plot} parameter, which
#' currently supports "r", "z" and "msample".
#' 
#' Red error bars or normal distribution fits signify that a Kolmogorov-Smirnov
#' test of the randomised r's was significantly non-normal at the level
#' specified by \code{ks.level} in \code{mantel.test}. If the veridical r is
#' plotted in blue it means that it was higher than all other r's generated by
#' the permutation test.
#' 
#' See \code{\link{mantel.development}} for more interesting example plots.
#' 
#' @param mantels a Mantel test result (a data frame of class \code{\link{mantel}})
#' @param plot the measure to be visualised, currently supported: "r", "z" and "msample"
#' @param ... additional parameters to be passed on to the plotting function
#' @examples
#' plot(mantel.test(hammingdists(allmeaningcombinations(c(2,2,2,2))), suppressWarnings(as.dist(1:16))))
#' plot(mantel.test(hammingdists(allmeaningcombinations(c(2,2,2,2))), suppressWarnings(as.dist(1:16))), plot="z")
#' @seealso \link{\code{mantel.development}}, \link{\code{mantel.test}}, \link{\code{plot.default}}
#' @export
plot.mantel <- function(mantels, plot=if (nrow(mantels)==1) "msample" else "r", xlab="generation", ...) {
  # suppress x axis drawing in the subroutine
  mantel.plotfuns[[plot]](mantels, xaxt="n", xlab=xlab, ...)
  if (plot != "msample") {
    axis(1, at=1:nrow(mantels), labels=rownames(mantels))
  }
}
