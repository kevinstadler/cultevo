% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compositionality.R
\name{ssm.compositionality}
\alias{ssm.compositionality}
\alias{ssm.segmentation}
\title{Find a segmentation that maximises the overall coverage of all signals.}
\usage{
ssm.compositionality(x, y, groups = NULL)

ssm.segmentation(x, y, mergefeatures = FALSE)
}
\arguments{
\item{x}{a list or vector of character sequences}

\item{y}{a matrix or data frame with as many rows as there are
strings (see section Meaning data format)}

\item{groups}{a list or vector with as many items as strings, used to split
the signals and meanings into data sets for which the compositionality
measures are computed separately.}

\item{mergefeatures}{logical: if \code{TRUE}, \code{ssm.segmentation} will
try to improve on the initial solution by incrementally merging pairs of
meaning features as long as doing so improves the over string coverage
of the segmentation.}
}
\description{
This algorithm builds on Spike's measure of compositionality (see
\code{\link{sm.compositionality}}), except instead of simply determining
which segment(s) which have the highest mutual predictability for each
meaning feature separately, it tries to find a combination of
non-overlapping segments that maximises the overall string coverage over all
signals. In other words, it tries to find a segmentation which can account
for (or 'explain') as much of the string material in the signals as
possible.
}
\examples{
ssm.segmentation(c("as", "bas", "basf"),
  cbind(a=c(TRUE, FALSE, TRUE), b=c(FALSE, TRUE, TRUE)))

# TODO signaling system where one dimension is simply not encoded
}
\seealso{
\code{\link{sm.compositionality}}
}
