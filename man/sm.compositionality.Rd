% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compositionality.R
\name{sm.compositionality}
\alias{sm.compositionality}
\alias{sm.segmentation}
\title{Spike's measure of additive compositionality.}
\usage{
sm.compositionality(strings, meanings, groups = NULL)

sm.segmentation(strings, meanings)
}
\arguments{
\item{strings}{a list or vector of character sequences}

\item{meanings}{a matrix or data frame with as many rows as there are
strings (see below)}

\item{groups}{a list or vector with as many items as strings, used to split
\code{strings} and \code{meanings} into data sets for which
compositionality measures are computed separately.}
}
\description{
Implementation of the Spike-Montague information-theoretic measure of
additive compositionality (Spike 2016), which finds the most predictive
association between substrings and categorical meaning features. Additive
means that it does not take the ordering of elements into account, i.e.
\code{GREEN DOG = GREEN + DOG = DOG + GREEN}.
}
\details{
The measure really captures the degree to which a synonymy-free signalling
system exists at the level of semantic \emph{features}, rather than looking
for complex meanings per se. The resulting segmentations may therefore
overlap.

The segmentation algorithm scans through all sub-strings found in
\code{strings} to find the most bijective mapping onto all the meaning
features present in \code{meanings}, i.e. the pairings of sub-strings and
meaning features that are \emph{most predictive of each other}.
Mathematically, for every meaning feature \eqn{f\in M}, it tries to find
the sub-string \eqn{s_{ij}} from the set of strings \eqn{S} that maximises
\deqn{comp(f,S) = \max_{s_{ij}\in S} P(f|s_{ij}) \cdot P(s_{ij}|f)}.
}
\section{Functions}{
\itemize{
\item \code{sm.compositionality}: Calculates the mean predictability of all meaning features,
\eqn{C = \frac{1}{|M|} \sum_{f\in M} comp(m,S)}. Returns a vector of three
elements: \code{N}, the number of signal-meaning pairings on which the
computation was based, \code{comp}, the compositionality measure, and
\code{M}, the number of distinct meaning features over which the measure
was computed. (When \code{groups} is not \code{NULL}, returns a matrix with
the same elements along columns, with one row for every group.)

\item \code{sm.segmentation}: Finds the most predictive segment(s) for every meaning feature, i.e. the
substrings \eqn{s_{ij}} that maximise \eqn{P(m|s_{ij}) \cdot P(s_{ij}|m)}.
Returns a matrix with one row for every meaning feature, in descending order
of their predictability from (and to) their corresponding string segments.
}}

\section{Meaning data format}{

The \code{meanings} can be a matrix or data frame in one of two formats. If
it is a matrix of logicals (TRUE/FALSE values), then the columns are
assumed to refer to meaning \emph{features}, with individual cells
indicating whether the meaning feature is present or absent in the message
indicated by that row (see \code{\link{binaryfeaturematrix}} for an
explanation).
If \code{meanings} is a data frame or matrix of any other type, it is
assumed that the columns specify different meaning dimensions, with the
cell values showing the levels with which the different dimensions can be
realised. This dimension-based representation is automatically converted to
a feature-based one using \code{\link{binaryfeaturematrix}}. As a
consequence, whatever the actual types of the columns in the meaning
matrix, \emph{they will be treated as categorical factors} in order to
represent them as atomic meaning features.
}

\examples{
# perfect communication system
sm.compositionality(c("a", "b", "ab"),
  cbind(a=c(T, F, T), b=c(F, T, T)))
sm.segmentation(c("a", "b", "ab"),
  cbind(a=c(T, F, T), b=c(F, T, T)))

sm.compositionality(c("as", "bas", "basf"),
  cbind(a=c(T, F, T), b=c(F, T, T)))
sm.segmentation(c("as", "bas", "basf"),
  cbind(a=c(T, F, T), b=c(F, T, T)))

# the function also accepts meaning-dimension based matrix definitions:
enumerate.meaningcombinations(c(animal=2, colour=2))
sm.segmentation(c("greendog", "bluedog", "greencat", "bluecat"),
  enumerate.meaningcombinations(c(animal=2, colour=2)))
}
\references{
Spike, M. (2016). Minimal requirements for the cultural
  evolution of language. PhD thesis, The University of Edinburgh.
}
\seealso{
\code{\link{binaryfeaturematrix}}
}
