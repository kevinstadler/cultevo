<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Find a segmentation that maximises the overall string coverage across all signals. — ssm.compositionality • cultevo</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->
<link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cerulean/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>
<meta property="og:title" content="Find a segmentation that maximises the overall string coverage across all signals. — ssm.compositionality" />

<meta property="og:description" content="This algorithm builds on Spike's measure of compositionality (see
sm.compositionality), except instead of simply determining
which segment(s) have the highest mutual predictability for each
meaning feature separately, it attempts to find a combination of
non-overlapping segments for each feature that maximises the overall string
coverage over all signals. In other words, it tries to find a segmentation
which can account for (or 'explain') as much of the string material in the
signals as possible." />
<meta name="twitter:card" content="summary" />


<!-- mathjax -->
<script src='https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-96498670-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-96498670-1');
</script>



  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">cultevo</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">1.0.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">Overview</a>
</li>
<li>
  <a href="../reference/index.html">Function reference</a>
</li>
<li>
  <a href="../articles/page.test.html">Page test tutorial</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Find a segmentation that maximises the overall string coverage across all signals.</h1>
    
    <div class="hidden name"><code>ssm.compositionality.Rd</code></div>
    </div>

    
    <p>This algorithm builds on Spike's measure of compositionality (see
<code><a href='sm.compositionality.html'>sm.compositionality</a></code>), except instead of simply determining
which segment(s) have the highest mutual predictability for each
meaning feature separately, it attempts to find a combination of
non-overlapping segments for each feature that maximises the overall string
coverage over all signals. In other words, it tries to find a segmentation
which can account for (or 'explain') as much of the string material in the
signals as possible.</p>
    

    <pre class="usage"><span class='fu'>ssm.compositionality</span>(<span class='no'>x</span>, <span class='no'>y</span>, <span class='kw'>groups</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)

<span class='fu'>ssm.segmentation</span>(<span class='no'>x</span>, <span class='no'>y</span>, <span class='kw'>mergefeatures</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>, <span class='kw'>verbose</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>x</th>
      <td><p>a list or vector of character sequences</p></td>
    </tr>
    <tr>
      <th>y</th>
      <td><p>a matrix or data frame with as many rows as there are
strings (see section Meaning data format)</p></td>
    </tr>
    <tr>
      <th>groups</th>
      <td><p>a list or vector with as many items as strings, used to split
the signals and meanings into data sets for which the compositionality
measures are computed separately.</p></td>
    </tr>
    <tr>
      <th>mergefeatures</th>
      <td><p>logical: if <code>TRUE</code>, <code>ssm.segmentation</code> will
try to improve on the initial solution by incrementally merging pairs of
meaning features as long as doing so improves the overall string coverage
of the segmentation.</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>logical: if <code>TRUE</code>, messages detailed information about
the number of segment combinations considered for every coverage computed.</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>For large data sets and long strings, this computation can get very slow.
If the attested signals are such that no perfect segmentation is possible,
this algorithm is not guaranteed to find any segmentation (as no such
segmentation might exist).</p>
    
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <div class='dont-index'><p><code><a href='sm.compositionality.html'>sm.compositionality</a></code></p></div>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='fu'>ssm.segmentation</span>(<span class='fu'>c</span>(<span class='st'>"as"</span>, <span class='st'>"bas"</span>, <span class='st'>"basf"</span>),
  <span class='fu'>cbind</span>(<span class='kw'>a</span><span class='kw'>=</span><span class='fu'>c</span>(<span class='fl'>TRUE</span>, <span class='fl'>FALSE</span>, <span class='fl'>TRUE</span>), <span class='kw'>b</span><span class='kw'>=</span><span class='fu'>c</span>(<span class='fl'>FALSE</span>, <span class='fl'>TRUE</span>, <span class='fl'>TRUE</span>)))</div><div class='output co'>#&gt; <span class='message'>Checking 9 segment combinations for overlaps...</span></div><div class='output co'>#&gt; <span class='message'>Initial segmentation covers 6 of 9 characters, mean mp 0.833</span></div><div class='output co'>#&gt;   N matches matchrate    mp     p segments
#&gt; b 2       2         1 1.000 0.651        b
#&gt; a 2       2         1 0.667 0.994       as
#&gt; 
#&gt; Mean feature-wise mutual predictability, weighted by feature frequency: 0.833 
#&gt; Mean signal-wise character coverage, weighted by features per signal: 0.708 
#&gt; 
#&gt; Segmentation is based on 3 signals totalling 9 characters.
#&gt; Discounting overlaps, the segmentation above accounts for 6 of those characters.
#&gt; Total character coverage rate: 0.667 </div><div class='input'>

<span class='co'># signaling system where one meaning distinction is not encoded in the signals</span>
<span class='fu'>print</span>(<span class='no'>threebytwoanimals</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='enumerate.meaningcombinations.html'>enumerate.meaningcombinations</a></span>(<span class='fu'>list</span>(<span class='kw'>animal</span><span class='kw'>=</span><span class='fu'>c</span>(<span class='st'>"dog"</span>, <span class='st'>"cat"</span>, <span class='st'>"tiger"</span>),
  <span class='kw'>colour</span><span class='kw'>=</span><span class='fu'>c</span>(<span class='st'>"col1"</span>, <span class='st'>"col2"</span>))))</div><div class='output co'>#&gt;      animal  colour
#&gt; [1,] "dog"   "col1"
#&gt; [2,] "dog"   "col2"
#&gt; [3,] "cat"   "col1"
#&gt; [4,] "cat"   "col2"
#&gt; [5,] "tiger" "col1"
#&gt; [6,] "tiger" "col2"</div><div class='input'>
<span class='fu'>ssm.segmentation</span>(<span class='fu'>c</span>(<span class='st'>"greendog"</span>, <span class='st'>"bluedog"</span>, <span class='st'>"greenfeline"</span>, <span class='st'>"bluefeline"</span>, <span class='st'>"greenfeline"</span>, <span class='st'>"bluefeline"</span>),
  <span class='no'>threebytwoanimals</span>)</div><div class='output co'>#&gt; <span class='message'>Checking 1 segment combinations for overlaps...</span></div><div class='output co'>#&gt; <span class='message'>Initial segmentation covers 57 of 57 characters, mean mp 0.833</span></div><div class='output co'>#&gt;              N matches matchrate  mp     p segments
#&gt; animal=dog   2       2         1 1.0 0.982      dog
#&gt; colour=col1  3       3         1 1.0 0.615    green
#&gt; colour=col2  3       3         1 1.0 0.615     blue
#&gt; animal=cat   2       2         1 0.5     1   feline
#&gt; animal=tiger 2       2         1 0.5     1   feline
#&gt; 
#&gt; Mean feature-wise mutual predictability, weighted by feature frequency: 0.833 
#&gt; Mean signal-wise character coverage, weighted by features per signal: 1 
#&gt; 
#&gt; Segmentation is based on 6 signals totalling 57 characters.
#&gt; Discounting overlaps, the segmentation above accounts for 57 of those characters.
#&gt; Total character coverage rate: 1 </div><div class='input'>
<span class='co'># the same analysis again, but allow merging of features</span>
<span class='fu'>ssm.segmentation</span>(<span class='fu'>c</span>(<span class='st'>"greendog"</span>, <span class='st'>"bluedog"</span>, <span class='st'>"greenfeline"</span>, <span class='st'>"bluefeline"</span>, <span class='st'>"greenfeline"</span>, <span class='st'>"bluefeline"</span>),
  <span class='no'>threebytwoanimals</span>, <span class='kw'>mergefeatures</span><span class='kw'>=</span><span class='fl'>TRUE</span>)</div><div class='output co'>#&gt; <span class='message'>Checking 1 segment combinations for overlaps...</span></div><div class='output co'>#&gt; <span class='message'>Initial segmentation covers 57 of 57 characters, mean mp 0.833</span></div><div class='output co'>#&gt; <span class='message'>Merging animal=cat|animal=tiger improved coverage to 57 out of 57, mean mp 1</span></div><div class='output co'>#&gt;                         N matches matchrate mp     p segments
#&gt; animal=dog              2       2         1  1 0.982      dog
#&gt; colour=col1             3       3         1  1 0.615    green
#&gt; colour=col2             3       3         1  1 0.615     blue
#&gt; animal=cat|animal=tiger 4       4         1  1 0.701   feline
#&gt; 
#&gt; Mean feature-wise mutual predictability, weighted by feature frequency: 1 
#&gt; Mean signal-wise character coverage, weighted by features per signal: 1 
#&gt; 
#&gt; Segmentation is based on 6 signals totalling 57 characters.
#&gt; Discounting overlaps, the segmentation above accounts for 57 of those characters.
#&gt; Total character coverage rate: 1 </div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#details">Details</a></li>

      <li><a href="#see-also">See also</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Kevin Stadler.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  

  </body>
</html>

